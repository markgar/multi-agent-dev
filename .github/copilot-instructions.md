# Copilot Instructions

## About this codebase

This software is entirely written by GitHub Copilot. The code is structured to be readable, modifiable, and extendable by Copilot (and other LLM-based agents). Every design decision should reinforce that.

### Guidelines for Copilot-friendly code

- **Flat, explicit control flow.** Prefer straightforward if/else and early returns over deeply nested logic, complex inheritance hierarchies, or metaprogramming. Every function should be understandable from its source alone.
- **Small, single-purpose functions.** Keep functions short (ideally under ~40 lines). Each function does one thing with a clear name that describes it. This gives Copilot better context boundaries.
- **Descriptive naming over comments.** Variable and function names should make intent obvious. Use comments only when *why* isn't clear from the code — never to explain *what*.
- **Colocate related logic.** Keep constants, helpers, and the code that uses them close together (or in the same small file). Avoid scattering related pieces across many modules — Copilot works best when relevant context is nearby.
- **Consistent patterns.** When multiple functions do similar things, structure them identically. Consistent shape lets Copilot reliably extend the pattern.
- **No magic.** Avoid decorators that hide behavior, dynamic attribute access, implicit registration, or monkey-patching. Everything should be traceable by reading the code top-to-bottom.
- **Simple string templates for prompts.** Keep LLM prompts as plain format strings with named placeholders. No template engines, no runtime assembly — just `.format()` or f-strings.
- **Graceful error handling.** Wrap I/O and subprocess calls in try/except. Never let a transient failure crash the orchestration loop. Log the error and continue.
- **Minimal dependencies.** Only add a dependency when it provides substantial value. Fewer deps mean less surface area for Copilot to misunderstand.
- **One concept per file.** Each module owns a single concern. Don't mix unrelated responsibilities in the same file.

## Project structure

- **Source code lives in `src/agent/`** — this is the only directory to edit.
- **`build/`** is a Python build artifact generated by setuptools/pip. Never edit files in `build/`. It is regenerated automatically and should be treated as read-only.
- **`pyproject.toml`** defines the package. The project uses a `src/` layout with the package name `agent`.

## Key files

- `src/agent/cli.py` — CLI commands (typer app): `go`, `resume`, `build`, `plan`, `commitwatch`, `testloop`, etc.
- `src/agent/prompts.py` — All LLM prompt templates. Constants only, no logic.
- `src/agent/utils.py` — Shared helpers: logging, git operations, milestone tracking, builder sentinel.
- `src/agent/config.py` — Language/stack configurations and prerequisites.

## Architecture

This is a multi-agent orchestrator that uses GitHub Copilot CLI (`copilot --yolo`) as the execution engine. Agents (builder, planner, reviewer, tester) run as separate processes in separate git clones of the same repo. They coordinate through:

- **Markdown files** (`TASKS.md`, `BUGS.md`, `REVIEWS.md`) — shared state via git push/pull.
- **Log files** (`logs/`) — local coordination signals like `builder.done`, `reviewer.checkpoint`, `milestones.log`.

The build loop (Python code in `cli.py`) handles deterministic orchestration — milestone boundary tracking, SHA recording, shutdown signals. The LLM agents handle creative work — writing code, reviewing diffs, writing tests.

## Conventions

- Agent prompts are append-only format strings in `prompts.py`. Use `.format()` for interpolation.
- All file I/O helpers in `utils.py` wrap operations in try/except and never crash the workflow over I/O errors.
- `resolve_logs_dir()` finds the project-root `logs/` directory regardless of which clone (builder/reviewer/tester) the code is running in.
